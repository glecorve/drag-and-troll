package modeles.personnages;

import java.util.ArrayList;
import java.util.List;

import javax.swing.ImageIcon;


import modeles.Case;
import modeles.Entite;
import modeles.collectables.Bouclier;
import modeles.collectables.Bourse;
import modeles.collectables.Coeur;
import modeles.collectables.Cristal;
import modeles.collectables.Objet;
import modeles.collectables.Piece;


/**
 * This class represents the troll object with which the player will play as the main character
 * @author prukev, Brahim
 *
 */
public class Troll extends Personnage {
	
	/**
	 * Maximum number of moves for any troll
	 */
	private static final int DEPLACEMENT_MAX_TROLL = 1;

	/**
	 * Each troll has a score for the concerned player
	 */
	private int score;
	
	/**
	 * A troll has some life points. If it's zero, the troll is removed from the game
	 */
	private int vies;
	
	/**
	 * A troll can have some magic. If he is it, he awakes the dragon
	 */
	private int magie;
	
	/**
	 * This position will be use if the troll must return at home
	 */
	private Case depart;
	
	/**
	 * For each troll there is an associated player
	 */
	private int joueur;
	
	/**
	 * Each troll can have a shield in order to protect itself from the dragon
	 */
	private int bouclier;
	
	/**
	 * This picture will be use when the troll has no shield
	 */
	private ImageIcon withoutShield;
	
	/**
	 * When a troll picks up a shield, this picture will be used
	 */
	private ImageIcon withShield;
	
	/**
	 * ArrayList in which we put the troll incomes 
	 */
	private List<Objet> butin = new ArrayList<Objet>();
	
	/**
	 * This data can give us the number of Troll there is in the game. It's also use for the id.
	 */
	private static int nbTrolls = 1;
	
	/**
	 * This is the troll's constructor. It has an image and start with a score at 0, 3 life points,
	 * no magic, 1 max move and no shield
	 * @param img
	 */
	@SuppressWarnings("static-access")
	public Troll(ImageIcon img, ImageIcon shield) {
		this.myPicture = img;
		this.withoutShield = img;
		this.withShield = shield;
		this.score = 0;
		this.vies = 3;
		this.magie = 0;
		this.deplacementMax = DEPLACEMENT_MAX_TROLL;
		this.id = "Troll_" + this.nbTrolls;
		this.nbTrolls++;
		this.bouclier = 0;
	}
	
	@Override
	public Object clone() {
		Troll t = new Troll(this.withoutShield, this.withShield);
		t.copy(this);
		t.bouclier = this.bouclier;
		t.depart = (Case) this.depart.clone();
//		t.depart = this.depart; // No clone
		t.butin = new ArrayList<Objet>();
		for (Objet o : this.butin) {
			t.butin.add((Objet) o.clone());
		}
		t.joueur = this.joueur;
		t.magie = this.magie;
		t.score = this.score;
		t.vies = this.vies;
		return t;
	}
	
	/**
	 * This function moves the troll to its first position at the beginning of the game.
	 */
	public void retourCaseDepart() {
		this.position.deleteEntite(this);
		this.position = depart;
		this.position.addEntite(this);
		if(this.vies>0){
			this.vies--;
		}
	}
	
	/**
	 * Start position setter
	 * @param e
	 */
	public void setDepart(Case e) {
		this.depart = e;
	}
	
	/**
	 * Function updating the score
	 * @param bonus
	 */
	public void addScore(int bonus) {
		this.score += bonus;
	}
	
	/**
	 * Function updating the life points
	 * @param bonus
	 */
	public void addLife(int bonus) {
		if(this.vies < 3){
			this.vies += bonus;
		}
	}
	
	/**
	 * Function used when the troll picks up an item on the same position this items are added into this troll incomes
	 */
	public void addItem() {
		ArrayList<Entite> list = this.position.getEntites();
		if (list.get(0) != null && list.get(0) instanceof Objet) {
			Objet it = (Objet)list.get(0);
			if ((it instanceof Coeur && compterCoeurs() < 3) || (it instanceof Bouclier && 
					compterBoucliers() <1) || (it instanceof Cristal && compterCristaux() < 2) || 
					it instanceof Piece || it instanceof Bourse) {
				    butin.add(it);
				    list.remove(it);
			}
			
		}
	}

	/**
	 * HashCode function. Generated by eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((depart == null) ? 0 : depart.hashCode());
		result = prime * result + magie;
		result = prime * result + vies;
		result = prime * result + score;
		return result;
	}

	/**
	 * Equals function. Generated by eclipse
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (!(obj instanceof Troll)) {
			return false;
		}
		Troll other = (Troll) obj;
		if (depart == null) {
			if (other.depart != null) {
				return false;
			}
		} else if (!depart.equals(other.depart)) {
			return false;
		}
		if (magie != other.magie) {
			return false;
		}
		if (vies != other.vies) {
			return false;
		}
		if (score != other.score) {
			return false;
		}
		if (id != other.id) {
			return false;
		}
		return true;
	}

	/**
	 * ToString function. Customized 
	 */
	@Override
	public String toString() {
		return "Troll [id=" + id + ", score=" + score + ", nbLifes=" + vies + ", magie=" + magie + ", depart=" + depart + ", actuelle=" + position
				+ ", joueur=" + joueur + ", bouclier=" + bouclier + "]";
	}

	/**
	 * Score getter
	 * @return the score
	 */
	public int getScore() {
		return score;
	}
	
	/**
	 * If a troll is touched by the dragon's fire, he returns to its start position
	 */
	@Override
	public void dragonEffet() {
		if (this.bouclier == 0) this.retourCaseDepart();
		else {
			this.bouclier--;
			this.myPicture = this.withoutShield;
		}
	}
	
	/**
	 * Player getter
	 * @return joueur
	 */
	public int getJoueur() {
		return this.joueur;
	}
	
	/**
	 * Player setter
	 * @param joueur
	 */
	public void setJoueur(int joueur) {
		this.joueur = joueur;
	}

	/**
	 * life points getter
	 * @return nbLifes
	 */
	public int getVies() {
		return this.vies;
	}

	/**
	 * Life points setter
	 * @param nbLifes
	 */
	public void setVies(int nbLifes) {
		this.vies = nbLifes;
	}

	/**
	 * Magic getter
	 * @return magie
	 */
	public int getMagie() {
		return magie;
	}

	/**
	 * Magic setter
	 * @param magie
	 */
	public void setMagie(int magie) {
		if(this.magie>0){
			this.magie = magie;
		}
	}

	/**
	 * Score setter
	 * @param score
	 */
	public void setScore(int score) {
		this.score = score;
	}
	
	/**
	 * Function adding magic points
	 * @param bonus
	 */
	public void addMagie(int bonus) {
		if(this.magie < 2){
			this.magie += bonus;
		}
	}

	/**
	 * 
	 * @return bouclier if it's return 0, there is no shield
	 */
	public int getBouclier() {
		return this.bouclier;
	}

	/**
	 * Shield setter
	 * @param bouclier
	 */
	public void setBouclier(int bouclier) {
		this.bouclier = bouclier;
	}
	
	/**
	 * This function is used when a troll picks up a shield
	 * @param bonus
	 */
	public void addBouclier(int bonus) {
		if(this.bouclier < 1){
			this.bouclier += bonus;
			this.myPicture = this.withShield;
		}
	}

	/**
	 * Getter of the start position
	 * @return depart
	 */
	public Case getDepart() {
		return depart;
	}

	/**
	 * Return the bag of the troll
	 * @return incomes
	 */
	public List<Objet> getButin() {
		return butin;
	}

	/**
	 * Setter of the bag
	 * @param incomes
	 */
	public void setButin(List<Objet> butin) {
		this.butin = butin;
	}
	
	/**
	 * This function validates all the collected items
	 */
    public void validerButin(){
    	for(Objet it:butin) {
    		it.effet(this);
    	}
    	butin=new ArrayList<Objet>();
    }

    /**
     * This function count shields in the ArrayList incomes
     *  @return shield
     */
    public int compterBoucliers(){
    	int shield=this.getBouclier();
    	for(Objet it:butin){
    		if(it instanceof Bouclier)
    		shield++;
    	}
    	return shield;
    }
    
    /**
     * This function count hearts in the ArrayList incomes
     *  @return hearts
     */
    public int compterCoeurs(){
    	int hearts=this.getVies();
    	for(Objet it:butin){
    		if(it instanceof Coeur)
    			hearts++;
    	}
    	return hearts;
    }
    
    /**
     * This function count cristals in the ArrayList incomes
     * @return cristal
     */
    public int compterCristaux(){
    	int cristal=this.getMagie();
    	for(Objet it:butin){
    		if(it instanceof Cristal)
    			cristal++;
    	}
    	return cristal;
    }
    
}
